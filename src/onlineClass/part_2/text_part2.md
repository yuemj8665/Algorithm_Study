# 한번에 끝내는 코딩 테스트 369

1. [**MJ's Jupyter notebook**](http://localhost:8888/tree/Jupyter/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_%EC%9E%90%EB%A3%8C_20210426)
    - Jupyter notebook 실행 후 해당 주소로 접근하기


## 10. 버블정렬
### 0. 알고리즘 연습방법
- 알고리즘을 잘 작성하기 위해서는 잘 작성된 알고리즘을 이해하고 스스로 만들어봐야 한다.
    - 모사!  그림을 잘 그리기 위해서는 잘 그린 그림을 모방하는 것 부터 시작하는게 좋다.
    > 이번 챕터부터 알고리즘의 시작
  
- 알고리즘 연습 방법
1. 연습장과 펜을 준비
2. 알고리즘 문제를 읽고 분석 한 뒤
3. 간단하게 테스트용으로 매우 간단한 경우부터 복잡한 경우를 순서대로 생각해보면서 연습장과 펜을 이용하여 알고리즘을 분석한다.
4. 가능한 알고리즘이 보인다면, 구현할 알고리즘을 세부 항목(Case)으로 나누고, 문장으로 세부항목을 나누어서 적는다.
5. 코드화 하기 위해, 데이터 구조 또는 사용 할 변수를 정리
6. 각 문자을 코드 레벨로 적는다
7. 변수가 코드에 따라 어떻게 변하는지 손으로 적으면서 임의 데이터로 코드가 정상 동작하는지를 연습장과 펜으로 검증한다.
> 분석을 잘 한다면 손코딩에서도 굉장히 유용하다.
> 
> 코딩 테스트는 오랜 고민 끝에 소스를 입력해야한다. 

### 1. 정렬(Sorting) 이란?
- 정렬(sorting) : 어떤 데이터들이 이를 정해진 순서대로 나열하는 것
- 정렬은 프로그램 작성 시 빈번하게 필요로 한다.
- 다양한 알고리즘이 고안되어있으며, 알고리즘 학습의 필수이다.

###2. 버블 정렬이란?
- 두 인접한 데이터를 비교해서 앞에 있는 데이터가 뒤에있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘.

###3. 어떻게 코드로 짜는가?
> 알고리즘 연습 방법에 기반해서 단계별로 생각하기
```java
public static class BubbleSort{
        /**
         * 데이터가 4개 이상일때 버블정렬하기
         * 특이점 :
         * n개의 리스트가 있는 경우 최대 n-1번의 로직을 적용한다.
         * 로직을 1번 적용할 때마다 가장 큰 숫자가 뒤에서부터 1개씩 결정된다.
         * 로직이 경우에따라 일찍 끝날 수도있다.
         * 따라서 로직을 적용할때 한번도 데이터가 교환된 적이 없다면 이미 정렬된 상태이므로 더이상 로직을 반복 적용할 필요가 없다.
         *
         * @param dataList
         * @return
         */
        public ArrayList<Integer> sort(ArrayList<Integer> dataList) {
            for (int i = 0; i < dataList.size() - 1; i++) {
                boolean swap = false;
                for (int index = 0; index < dataList.size() - 1 - i; index++) {
                    if (dataList.get(index) > dataList.get(index + 1)) {
                        Collections.swap(dataList,index,index+1);
                        swap = true;
                    }
                }
                if (swap == false) {
                    break;
                }
            }
            return dataList;
        }
    }
```

###4. 복잡도 계산하기
- 반복문이 2개 O(n^2)
  <img src="https://blogfiles.pstatic.net/MjAyMTA3MThfMjgg/MDAxNjI2NjE0ODcxNDI1.afG-SHEu-V2kFmdAGFzrnn0C0HoEapUFo5cwiiOUEIQg.FaXeRkEUPN7krreva6I8gNJgtd9IpppJpxsWzmGDkOYg.PNG.yuemj/%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%B4_2%EA%B0%9C.png?type=w1" />
    - 최악의 경우 n(n-1)/2
- 완전정렬이 되어있는 경우 O(n)
> 버블 정렬을 알고리즘 연습 방법에 따라서 코드를 보지않고 연습하기.

## 11. 선택정렬
### 1] 선택정렬이란?
- 다음과 같은 순서를 반복하며 정렬하는 알고리즘
    - 주어진 데이터 중, 최소값을 찾는다
    - 해당 최소값을 데이터 맨 앞에 위치한 값과 교체한다
    - 맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복한다.

#### 직접 눈으로 보면 더 이해가 쉽다: https://visualgo.net/en/sorting

<img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" width=100>

### 2] 코드를 만드는 방법?
> 간단히 로직에 집중해서 각각의 데이터가 저장되어있는 배열이 있다고 가정하기

- 데이터가 두 개 일떄,
    - 예 : DataList[0]과 DataList[1]의 값을 교환한다.
    
- 데이터가 세 개 일때,
    - 예 : dataList = [9,1,7]
    - 1번 실행 : [1,9,7]
    - 2번 실행 : [1,7,9]
    
- 데이터가 네 개 일때,
    - 예 : dataList = [9,3,2,1]
    - 1번 실행 : [1,3,2,9]
    - 2번 실행 : [1,2,3,9]
    - 3번 실행 : 변화 없음으로 회전 끝
    
### 3] 알고리즘 분석
- 반복문이 2개 O(n^2)
    -실제로 상세하게 표현하자면 n(n-1)/2
- 버블정렬과 비슷하다.

## 11. 삽입정렬
### 0] 삽입정렬이란?
- 삽입 정렬은 두번째 인덱스부터 시작한다.
- 해당 인덱스 값(key값) 앞에 있는 데이터부터 비교해서 key값이 더 작으면 B값을 뒤 인덱스로 복사
- 이를 key값이 더 큰 데이터를 만날때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 key값을 이동.
  <img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" />


### 1] 어떻게 코드로 만들까?
> 알고리즘 연습 방법에 기반하여 단계별로 생각하기
- 데이터가 두 개일 때 삽입정렬
  - 데이터 예시 list = [5,3]
  - 3이 보다 작음으로 교환, 결과적으로 [3,5]가 됨
- 데이터가 세 개일 때 삽입정렬
  - 데이터 예시 list = [5,3,2]
  - 두 번째 인덱스부터 시작, 3이 더 작음으로 3이 앞으로 가게됨 [3,5,2]
  - 세 번쨰 인덱스 시작, 2는 5보다 작고, 3보다도 작음 [2,3,5]
  - think) 세 번쨰 인덱스 시작 시, 2와 5와 3을 비교할때에 앞자리와 비교하는 반복문을 사용하는 것 같다.
- 데이터가 네 개일 때 삽입정렬
    - 데이터 예시 list = [5,3,2,4]
    - 두 번째 인덱스부터 시작, 3이 더 작음으로 3이 앞으로 가게됨 [3,5,2,4]
    - 세 번쨰 인덱스 시작, 2는 5보다 작고, 3보다도 작음 [2,3,5,4]
    - 네 번쨰 인덱스 시작, 4는 5보다 작고 3보다 크므로 [2,3,4,5]
    - think) 네 번쨰 인덱스가 3과 비교할때에는 어차피 앞쪽 인덱스와 더이상 비교를 할 이유가 없으니 false를 반환해서 앞자리와 비교하는 반복문을 끝내면 좋을 것 같다.
 
   
- 반복해야 되는 것.
  - list의 한 사이클의 회전이 필요함(list.size()-1)
  - list안에서 본인의 인덱스 앞쪽 비교해야하는데, 이걸 계속 반복하다가 break를 걸어야한다.
    - 비교하다가 앞쪽과 비교해서 작으면 스왑해야한다. 크다면 break.
> 데이터가 반복문이 되는것을 생각 해 보자.
> 

### 2] 알고리즘 분석
- 반복문은 2개가 있다.
- 최악의 경우 모든 회전을 닿는다.
- 완전 정렬이 되어있다면 반복문은 단 한번만 돌게된다.

## 12. 재귀용법
### 1] 재귀용법이란?
- 함수 안에서 본인(함수)를 호출하는 형태.
- 여러 알고리즘 작성 시 사용되므로 익숙해져야 한다.
### 2] 재귀용법의 이해
- 예제를 풀어보며, 재귀용법을 이해해보기
- 예제 : 팩토리얼을 구하는 알고리즘을 재귀용법을 활용하여 알고리즘 작성해보자.
    - 팩토리얼 : 
        2! : 1 X 2, 3! : 1 X 2 X 3 ...
#### 예제 - 분석하기
- 간단한 경우부터 생각해보기
    * 2! = 1 X 2
    * 3! = 1 X 2 X 3
    * 4! = 1 X 2 X 3 X 4 = 4 X 3!
- 규칙이 보임: n! = n X (n - 1)!
    1. 함수를 하나 만든다.
    2. 함수(n) 은 n > 1 이면 return n X 함수(n - 1)
    3. 함수(n) 은 n = 1 이면 return n
- 검증 (코드로 검증하지 않고, 직접 간단한 경우부터 대입해서 검증해야 함)
    1. 먼저 2! 부터
    - 함수(2) 이면, 2 > 1 이므로 2 X 함수(1)
        - 함수(1) 은 1 이므로, return 2 X 1 = 2 맞다!
    2. 먼저 3! 부터
    - 함수(3) 이면, 3 > 1 이므로 3 X 함수(2)
        - 함수(2) 는 결국 1번에 의해 2! 이므로, return 2 X 1 = 2
        - 3 X 함수(2) = 3 X 2 = 3 X 2 X 1 = 6 맞다!
    3. 먼저 4! 부터
    - 함수(4) 이면, 4 > 1 이므로 4 X 함수(3)
        - 함수(3) 은 결국 2번에 의해 3 X 2 X 1 = 6
        - 4 X 함수(3) = 4 X 6 = 24 맞다!

```java
// 일반적인 형태1
function(입력) {
    if (입력 > 일정값) {             // 입력이 일정 값 이상이면
        return function(입력 - 1);  // 입력보다 작은 값
    } else { // 어느 순간 본인을 호출하지 않도록 브레이크를 잘 걸어줘야 함
        return 특정값; // 재귀 호출 종료
    }
}
```

```java
// 일반적인 형태2
function(입력) {
    if (입력 <= 일정값) { // 입력이 일정 값보다 작으면
        return 특정값    // 재귀 호출 종료
    }  
    return function(입력 - 1);
}
```

> 내가 한 예제는 일반적인 형태2에 어느정도 해당되는 것 같다.

- 재귀호출은 스택의 전형적인 예이다.
    - 함수는 내부적으로 스택처럼 관리 된다.
      <img src="https://www.fun-coding.org/00_Images/recursivecall.png" />
      
## 13. 동적 계획법(Dynamic Prograaming)과 분할 정복(Divide and Conquer)
### 0] 동적 계획법과 분할정복?
- 어떤 특정 문제를 풀기 위한 알고리즘은 아니지만, **전략**이라고 보면 된다.
- 두 기법은 유사한 점이 많다.

### 1] 정의
- 동적계획법(DP)
    - 입력 크기가 작은 문제를 해결, 해당 부분의 문제의 해를 활용해서 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 방법.
    - 상향식 해결법 : 가장 작은 문제의 해결법을 먼저 구한 후 해당 값을 이용하여 상위 문제를 풀어나가는 형식이다.
    - Memoiztion(메모리제이션) 기법 : 프로그램 실행 시 **이전에 실행하여 나온 결과값을 저장**하여 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술.
    - 문제를 잘게 쪼갤 때, 부분 문제는 재활용되어 다시 사용한다.
        - 예) 피보나치 수열
    - 
    
- 분할 정복
    - 문제를 나눌 수 없을 때까지 나누어서 각각 해결하면서 다시 합병, 문제의 답을 알아내는 알고리즘
    - 하향식 접근법으로, 상위의 답을 구하고나서 하위의 답을 구하여 모든 해답을 얻음
        - 일반적으로 재귀함수로 구현한다.
        - 상위의 답을 구하기 위해서 조각조각 나누다보니 하위의 답을 구하게된다.. 라는 개념.
    - 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않는다.
        - 에) 병합 정렬, 퀵 정렬
    
### 2] 공통점, 차이점
- 공통점
    - 문제를 잘개 쪼개서 가장 작은단위로 분할 한 후 해결법을 찾는다.
    
- 차이점
    - 동적 계획법
        - 부분 문제는 중복되어, 상위 문제 해결 시 재활용 된다.
        - Memoiztion 기법을 사용 (부분 문제의 답을 저장해서 재활용하는 기법을 사용)
    - 분할 정복
        - 부분 문제는 서로 중복되지 않는다.
        - Memoiztion 기법을 사용하지 않는다.

## 14. 병합 정렬(Merge Sort)
### 1] 병합 정렬 이란?
- 재귀용법을 사용하는 정렬 알고리즘
    1. 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
    2. 각 부분 리스트를 재귀적으로 다시 합병 정렬을 이용해 정렬한다.
    3. 두 부분 리스트를 하나의 정렬된 리스트로 합병한다.
<img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" width=500/>

- 병합 정렬은 두 가지 단계를 거친다.
    1. 끝없이 분할하는 분할 정복
        - 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘
        - 하향식 접근법으로, 상위의 해답을 구하기 위해 아래로 내려가면서 하위의 해답을 구하는 방식
            - 일반적으로 재귀함수로 표현한다.
        - 문제를 잘게 쪼갤때, 부분 문제는 서로 중복하지 않는다.
            - 에) 병합 정렬, 퀵 정렬 등
    2. 병합 시 각각의 데이터를 비교하여 정렬하여 병합한다.
         - 병합 할 때 각각의 데이터의 포인터를 두고, 가리키는 데이터끼리 비교하여 작은것부터 정렬시킨다.
    
### 2] 알고리즘 이해
- 데이터가 4개일 때,
    - 두 가지 단계를 거친다.
        1. 정렬 되지않은 배열을 끝까지 분할하는 단계
        2. 분리한 데이터를 단계별로 합치는 단계
    - 예시 dataList = [1,9,3,2]
        - 먼저 [1,9], [3,2]로 분할
        - 다시 앞 부분을 [1],[9] 로 분할 -> 1단계
        - 앞 부분을 정렬해서 병합 [1,9] -> 2단계
        - 뒷 부분을 분할 [3],[2] -> 1단계
        - 뒷 부분을 병합 [2,3] -> 2단계
        - [1,9]와 [2,3]을 병합
            - 두 배열의 맨 앞에 위치한 데이터부터 각각 비교하여 정렬로 합쳐진 배열을 작성한다.
                1. 1 < 2 -> [1]
                2. 9 > 2 -> [1,2]
                3. 9 > 3 -> [1,2,3]
                3. 9밖에 없으니 [1,2,3,9]
    > 굉장히 복잡함으로 그림을 가지고 이해하는 것이 제일 빠르다.

## 15. 퀵 정렬(Quick Sort)
### 1] 퀵 정렬이란?
- 정렬 알고리즘의 꽃
- 기준점(pivot)을 정해서 기준점보다 작은 데이터는 왼쪽, 큰 데이터는 오른쪽으로 모으는 함수를 작성한다.
  - pivot은 보통 맨 왼쪽 지정하는 듯 함.
- 각 왼쪽, 오른쪽은 재귀용법을 활용하여 다시 동일 함수를 호출하여 정렬한다.
    - 각 데이터는 재귀용법을 활용하여 데이터 수가 1개가 될때까지 반복호출을 하여 정렬한다.
- 함수는 왼쪽+기준점+오른쪽을 합쳐서 리턴한다.

### 2] 구현방법?
- 퀵 정렬 알고리즘은 세부 코드에 대해 연습을 통해 이해해야 한다.
- 퀵 정렬도 분할 정복 알고리즘 전략을 사용하여 정렬한다.

### 3] 알고리즘 분석
- 병합 정렬과 유사한 시간 복잡도를 가진다(O(nlog n))
    - 단 최악의 경우
        - 이미 정렬 된 배열에서 pivot이 가장 크거나, 가장 작으면 가장 큰 시간이 소요된다.
        - 모든 데이터를 한번씩 비교하는 상황이 나오게 되면 전혀 다른 시간 복잡도를 가진다.
        - O(n^2)가 나와버린다.
        - 근데 보통은 이미 정렬된 리스트를 집어넣는 경우는 별로 없다.
          <img src="https://www.fun-coding.org/00_Images/quicksortworks.jpg" />
          


## 16. 순차 탐색(Sequential Search)
### 1. 순차 탐색이란?
- 탐색은 여러 데이터 중에서 원하는 데이터를 찾아내는 것을 의미한다.
- 데이터가 담겨있는 리스트를 앞에서부터 하나씩 비교해가면서 원하는 데이터를 찾는 방법.
> 임의 배열이 있을 때 원하는 데이터의 위치를 리턴하는 순차 탐색 알고리즘 작성 해보기.
> 

## 17. 이진 탐색(Binary Search)
### 1. 이진 탐색이란?
- 탐색할 자료를 둘로 나누어 해당 데이터가 있을만한 곳을 탐색하는 방법.
- 정렬이 되어있어야 한다. 순차 탐색은 정렬이 필요없다.

### 2. 분할 정복 알고리즘과 이진 탐색
- 분할 정복 알고리즘(Divide and Conquer)
    - Divide : 문제를 하나 또는 둘 이상으로 나눈다.
    - Conquer : 나눠진 문제가 충분히 작고, 해결 가능하다면 해결하고 그렇지 않다면 다시 나눈다.
- 이진 탐색
    - Divide : 리스트를 두개의 서브 리스트로 나눈다
    - Conquer :
        - 검색 할 숫자 (search) > 중간값이면 뒷 부분의 서브 리스트에서 검색 할 숫자를 찾는다
        - 검색 할 숫자 (search) < 중간값이면 앞 부분의 서브 리스트에서 검색 할 숫자를 찾는다
    
### 3. 예시
> 1~30번쨰 병뚜껑에는 1~100 사이의 번호가 정렬되어 적혀있다. 이 중에 70이라는 숫자가 있을까 없을까?

### 4. 구현방법
- testData = {2,3,8,12,20}
    - searchFunc(dataList,findData) 함수 생성
        - searchItem : 찾는 숫자
        - dataList : 데이터 배열
        - dataList의 중간데이터와 searchItem을 비교해서
            - searchItem < dataList 중간값 이라면
                - 맨앞부터 dataList의 중간에서 다시 searchItem 찾기
            - dataList 중간값 < searchItem 이라면
                - dataList의 중간부터 맨 끝까지 다시 searchItem 찾기
            - 그렇지 않다면 dataList 중간값은 searchItem인 경우로, return.
    
### 5. 알고리즘 분석
- n개의 리스트를 매번 2로 나누어 1이 될떄까지 비교연산을 k회 진행한다.
- k+1이 최종 시간 복잡도가 된다.
- O(log n)


## 17. 그래프 알고리즘
###1] 그래프(Graph)란?
- 그래프는 실제 세계의 현상이나 사물의 정점(Vertex) 또는 노드(Node)와 간선(Edge)로 표현하기 위해 사용한다.
#### 예제 집에서 회사로 가는 경로를 그래프로 표현한 예
<img src="https://www.fun-coding.org/00_Images/graph.png" width=400>

###2] 그래프 관련 용어
- 노드(Node) : 위치를 말함, 정점(Vertex)이라고도 함.
- 간선(Edge) : 위치 간의 관계를 표시한 선으로 노드를 연결 한 선이라고 보면 됨(Link 또는 branch 라고도 한다.)
- 인접 정점(Adjacent Vertex) : 간선으로 직접 연결 된 정점(또는 노드)
- 참고 용어 :
    - 정점의 차수(Degree) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수
    - 진입 차수(In-Degree) : 방향 그래프에서 외부에서 오는 간선의 수 
    - 진출 차수(Out-Degree) : 방향 그래프에서 외부로 향하는 간선의 수
    - 경로 길이(Path Length) : 경로를 구성힉 위해 사용되는 간선의 수
    - 단순 경로(Simple Path) : 처음 정점과 끝 정점을 제외하고 중복된 정점이 없는 경로
    - 사이클(Cycle) : 단순 경로의 시작 정점과 종료 정점이 일치하는 경우
    > 단순 경로 (A - B - C) <br>
    A-B-C-A-B-D 와 같은 식의 경로는 중복된 정점이 있으므로 단순 경로가 아님<br>
<img src="https://www.fun-coding.org/00_Images/simplepath.png" width=200>

###3] 그래프의 종료
- 무방향 그래프(Undirected Graph)
    - 방향이 없는 그래프
    - 간선을 통해, 노드는 양 방향으로 갈수 있다.
    - 보통 노드 A,B가 연결되어있을 경우 (A,B) or (B,A)로 표기
    
<img src="https://www.fun-coding.org/00_Images/undirectedgraph.png" width=300>

- 방향 그래프(Directed Graph)
    - 간선의 방향이 있는 그래프
    - 보통 노드 A,B 가 A->B로 가는 간선으로 연결 되어있을 경우, <A,B> 로 표현한다.
        - 이 때, <B,A>는 **B->A로 가는 간선**이기때문에 성립되지 않음.
    
<img src="https://www.fun-coding.org/00_Images/directedgraph.png" width=300>

- 가중치 그래프(Weighted Graph), 또는 네트워크(Network)
    - 간선에 비용 또는 가중치가 할당 된 그래프

<img src="https://www.fun-coding.org/00_Images/weightedgraph.png" width=300>

#### 연결 그래프 (Connected Graph) 와 비연결 그래프 (Disconnected Graph)
- 연결 그래프 (Connected Graph)
    - 무방향 그래프에 있는 모든 노드에 대해 항상 경로가 존재하는 경우
- 비연결 그래프 (Disconnected Graph)
    - 무방향 그래프에서 특정 노드에 대해 경로가 존재하지 않는 경우

> 비연결 그래프 예 <br>
<img src="https://www.fun-coding.org/00_Images/disconnectedgraph.png" width=300>

#### 사이클 (Cycle) 과 비순환 그래프 (Acyclic Graph)
- 사이클 (Cycle)
    - 단순 경로의 시작 노드와 종료 노드가 동일한 경우
- 비순환 그래프 (Acyclic Graph)
    - 사이클이 없는 그래프

> 비순환 그래프 예 <br>
> <img src="https://www.fun-coding.org/00_Images/acyclicgraph.png" width=300>

#### 완전 그래프 (Complete Graph)
- 그래프의 모든 노드가 서로 연결되어 있는 그래프

> 완전 그래프 예 <br>
<img src="https://www.fun-coding.org/00_Images/completegraph.png" width=300>


### 4] 그래프와 트리의 차이
- 트리는 그래프 중에 속한 특별한 종류라고 볼 수 있다.
<div style="text-align:left">
<table>
  <tr>
    <th></th>
    <th style="text-align:center">그래프</th>
    <th style="text-align:center">트리</th>
  </tr>
  <tr>
    <td style="text-align:center">정의</td>
    <td style="text-align:left">노드와 노드를 연결하는 간선으로 표현되는 자료 구조</td>
    <td style="text-align:left">그래프의 한 종류, 방향성이 있는 비순환 그래프</td>
  </tr>
  <tr>
    <td style="text-align:center">방향성</td>
    <td style="text-align:left">방향 그래프, 무방향 그래프 둘다 존재함</td>
    <td style="text-align:left">방향 그래프만 존재함</td>
  </tr>
  <tr>
    <td style="text-align:center">사이클</td>
    <td style="text-align:left">사이클 가능함, 순환 및 비순환 그래프 모두 존재함</td>
    <td style="text-align:left">비순환 그래프로 사이클이 존재하지 않음</td>
  </tr>
  <tr>
    <td style="text-align:center">루트 노드</td>
    <td style="text-align:left">루트 노드 존재하지 않음</td>
    <td style="text-align:left">루트 노드 존재함</td>
  </tr>
  <tr>
    <td style="text-align:center">부모/자식 관계</td>
    <td style="text-align:left">부모 자식 개념이 존재하지 않음</td>
    <td style="text-align:left">부모 자식 관계가 존재함</td>
  </tr>
</table>
</div>


## 18. 너비 우선 탐색(Breadth First Search)
### 1] BFS란?
- 대표적인 그래프 **탐색** 알고리즘
    - 너비 우선 탐색(Breadth First Search) : 정점들과 같은 레벨에 있는 노드들(형제노드)을 먼저 탐색하는 방식
    - 깊이 우선 탐식(Depth First Search) : 정점의 자식들을 먼저 탐색하는 방식
    
- BFS/DFS 방식을 위한 예제
    - BFS : A-B-C-D-G-H-I-E-F-J
        - 한 단계씩 내려가면서, 해당 노드와 같은 레벨에 있는 노드들을 먼저 순회함
    - DFS : A-B-D-E-F-C-G-H-I-J
        - 한 노드의 자식을 타고 끝까지 순회 한 뒤, 다시 돌아와서 다른 형제들의 자식을 타고 순회함
<img src="https://www.fun-coding.org/00_Images/BFSDFS.png" width=700>
          
### 2] java로 표현하기?
- HashMap과 ArrayList를 활용한다.
- 인접한 노드들을 Key와 Value값으로 표현한다.
  <img src="https://www.fun-coding.org/00_Images/bfsgraph.png" width=700>
  
### 3-1] BFS의 java 구현
#### 1} 우선 두가지의 큐(quere)를 만든다.
- visited : 방문한다. 탐색한 노드. 방문하는 노드의 순서를 저장한다.
- needVisit : 탐색이 필요한 노드
- 큐는 ArrayList를 사용하여 간단히 구현한다.

### 3-2] DFS의 java 구현 (프로젝트: CH26_DFS)
- 자료구조 스택과 큐를 활용함
    - needVisit 스택과 visited 큐, 두 개의 자료 구조를 생성
> BFS 자료구조는 두 개의 큐를 활용하는데 반해, DFS 는 스택과 큐를 활용한다는 차이가 있음을 인지해야 함
### 4] 시간복잡도
- 일반적인 BFS 시간복잡도
    - 노드 수 V
    - 간선 수 E
        - 위 코드에서 while needVisit는 V+E번 수행한다.
    - 시간 복잡도는 O(V+E)
    - 전체 노드와 간선을 한번씩 훑기때문에 V+E이다.

## 19. 탐욕 알고리즘(Greedy Algorithm)
### 1] 탐욕 알고리즘이란?
- 최적의 해에 가까운 값을 구하기 위한 **전략**.
- 여러 경우 중 하나를 결정해야 할 때마다, 매 순간 최적이라고 생각되는 경우를 선택하는 방식으로 진행하여 최종적인 값을 구한다.

### 2] 탐욕 알고리즘의 예
- 문제 1) 동전문제
    - 지불해야 하는 값이 4,720원 일 때, 1원, 50원, 100원, 500원의 동전으로 동전의 수가 가장 적게 지불하시오.
    - 가장 큰 동전부터 최대한 지불해야 하는 값을 채우는 방식으로 구현 가능
    - 탐욕 알고리즘으로 매 순간 최적이라고 생각되는 경우를 선택하면 된다.
    
- 문제 2) 부분 배낭 문제 (Fractional Knapsack Problem) (프로젝트: CH27_KNAPSACK)
    - 무게 제한이 k인 배낭에 최대 가치를 가지도록 물건을 넣는 문제
    - 가치를 무게로 나누면 무게 당 가치가 나온다.  
        - 각 물건은 무게(w)와 가치(v)로 표현될 수 있음
        - 물건은 쪼갤 수 있으므로 물건의 일부분이 배낭에 넣어질 수 있음, 그래서 Fractional Knapsack Problem 으로 부름
            - Fractional Knapsack Problem 의 반대로 물건을 쪼개서 넣을 수 없는 배낭 문제도 존재함 (0/1 Knapsack Problem 으로 부름)
              
<img src="https://www.fun-coding.org/00_Images/knapsack.png">

### 3] Comparable 과 Comparator 인터페이스
- Comparable 와 Comparator 는 둘 다 인터페이스로, 정렬 기준을 구현하기 위해 사용됨
    - Comparable 인터페이스는 compareTo() 메서드를 override 해서 구현
        - 일반적으로는 정렬할 객체에 implements 로 Comparable 인터페이스를 추가하여 구현
    - Comparator 인터페이스는 compare() 메서드를 override 해서 구현
        - 일반적으로는 별도 클래스를 정의해서 구현하며, 따라서, 동일 객체에 다양한 정렬 기준을 가진 클래스를 작성 가능
    
### 4] 탐욕 알고리즘의 한계
- 탐욕 알고리즘은 근사치 추정에 활용한다.
- 반드시 최적의 해를 구할 수 있는것은 아님
- 최적의 해에 가까운 값을 구하는 방법 중 하나임
#### 예시
<img src="https://www.fun-coding.org/00_Images/greedy.png" width=300>

- '시작' 노드에서 시작해서 가장 작은 값을 찾아 leaf node 까지 가는 경로를 찾을 시에
    - Greedy 알고리즘 적용시 시작 -> 7 -> 12 를 선택하게 되므로 7 + 12 = 19 가 됨
    - 하지만 실제 가장 작은 값은 시작 -> 10 -> 5 이며, 10 + 5 = 15 가 답

    
## 20. 최단거리 알고리즘
### 1] 최단 경로 문제란?
- 두 노드를 잇는 가장 짧은 경로를 찾는 문제이다.
- 가중치 그래프(Weighted Graph)에서 간선(Edge)의 가중치 합이 최소로 되도록 경로를 찾는것이 목적이다.

### 2] 최단경로 문제의 종류
1. 단일 출발 (single-source) 최단 경로 문제
- 그래프 내의 특정 노드 u 에서 출발하여, 그래프 내의 모든 다른 노드에 도착하는 가장 짧은 경로를 찾는 문제
- 최단 경로가 노드 수만큼 나온다
2. 단일 도착 (single-destination) 최단 경로 문제
- 모든 노드들로부터 출발해서, 그래프 내의 특정 노드 u 로 도착하는 가장 짧은 경로를 찾는 문제
- 최단 경로가 노드 수만큼 나온다
3. 단일 쌍(single-pair) 최단 경로 문제
- 주어진 노드 u 와 v 간의 최단 경로를 찾는 문제
- 최단 경로가 단 한개만 나온다.
4. 전체 쌍(all-pair) 최단 경로: 그래프 내의 모든 노드 쌍 (u, v) 사이에 대한 최단 경로를 찾는 문제
- 전체 노드들을 모두 쌍으로 묶어서 각각의 경로에 대해 최단거리를 찾음

### 3] 다익스트라 알고리즘
- 다익스트라 알괴즘은 최단경로 문제 중 1번에 해당된다.
    - 하나의 정점에서 다른 모든 정점을 도착하는 가장 짧은거리를 구하는 문제이다.

<img src="https://www.fun-coding.org/00_Images/dijkstra.png" width=300>
    
> 그림에서 A->B로 가는 최단경로는 A>B로 가는 8이 아닌, A>C>B로 가는 1+5=6이다.

### 4] 다익스트라 알고리즘 예제
- 배열 생성
    - A->B로 가는 최단경로를 계산한다.
    - 배열에는 각각의 가중치를 넣는다.
    - A라는 노드에서 다른 노드로 갈때의 가중치를 배열에 넣는다. 그 외에 다른곳은 무한대로 놓는다.
    - 가장 작은 가중치(C)로 간다.
    - C라는 노드에서 다른 가중치로 갈떄의 가중치를 다시 배열에 넣으면서, A->B노드와 C->B노드의 가중치 값을 비교하여 업데이트 한다.

### 다익스트라 알고리즘 로직
- 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단 거리를 갱신하는 기법
- 다익스트라 알고리즘은 너비우선탐색(BFS)와 유사
    - 첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서, 첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트
>  다익스트라 알고리즘의 다양한 변형 로직이 있지만, 가장 개선된 우선순위 큐를 사용하는 방식에 집중해서 설명하기로 함

- 우선순위 큐를 활용한 다익스트라 알고리즘
    - 우선순위 큐는 MinHeap 방식을 활용해서, 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 됨

    1) 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장
        - 초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장함 (inf 라고 표현함)
        - 우선순위 큐에 (첫 정점, 거리 0) 만 먼저 넣음

    2) 우선순위 큐에서 노드를 꺼냄
        - 처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐
        - 첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교한다.
        - 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리를 업데이트한다.
        - 배열에 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 넣는다.
            - 결과적으로 너비 우선 탐색 방식과 유사하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨
            - 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드, 거리)의 경우에는 해당 노드와 인접한 노드간의 거리 계산을 하지 않음

    3) 2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복한다.

### 참고: PriorityQueue 와 정렬
- 다음 참고 항목에서 익히는 PriorityQueue 는 내부적으로 정렬 기능을 수행하며,
- 따라서 PriorityQueue 에 넣어지는 특별한 형태의 객체인 경우, 객체간의 정렬을 위한 기준을 정의해야 함
- PriorityQueue 에서 내부적으로 정렬 기능을 사용할 때는, 해당 객체의 Comparable 인터페이스의 compareTo() 메서드를 호출하므로,
- 객체간 정렬 기준을 정의하기 위해, Comparable 인터페이스의 compareTo() 메서드를 정의해줘야 함

### 5] 시간 복잡도
- 위 다익스트라 알고리즘은 크게 다음 주가지 과정을 거친다.
    - 과정1: 각 노드마다 인접한 간선들을 모두 검사한다.
    - 과정2: 우선순위 큐에 노드/거리정보를 넣고 삭제(pop)한다.
    
- 각 과정 별 시간 복잡도
    - 과정1: 각 노드는 최대 한번 씩 방문하므로(첫 노드와 해당 노드간의 갈 수 있는 루트가 있는 경우만 해당),
    그래프의 모든 간선은 최대 한번씩 검사한다.
        - 즉, 각 노드마다 인접한 간선들을 모두 검사하는 과정은 O(E) 시간이 걸림(E = edge)
      
    - 과정2: 우선순위 큐에 가장 많은 노드, 거리 정보가 들어가는 시나리오는 그래프의 모든 간선이 검사 될때마다 배열의 최단거리가 갱신되고 우선순위 큐에 노드/거리가 추가되는 것이다.
        - 이때 추가는 각 간선마다 최대 한번 일어나기 때문에, 최대 O(E)의 시간이 걸리고, O(E)개의 노드/거리 정보에 대해 우선순위 큐를 유지하는 작업은 O(logE)가 걸림
        - 해당 과정의 시간 복잡도는 O(ElogE)
    - 총 시간 복잡도 : 과정1 + 과정2 = O(E) + O(ElogE) = O(E + ElogE) = O(ElogE)

## 21. 최소 신장 트리
### 1] 신장트리란?
- Spanning Tree 또는 신장 트리라고 불리운다.
- 원래의 그래프의 모든 노드가 연결되어있으면서 트리의 속성을 만족하는 그래프
- 신장 트리의 조건
    - 본래의 그래프의 모든 노드를 포함해야 한다.
    - 모든 노드가 서로 연결되어있어야 한다.
    - 트리의 속성을 만족시킨다(사이클이 존재하지 않는다)
 
### 2] 최소 신장 트리
- Minimum Spanning Tree, MST라고 불린다.
- 가능한 Spanning Tree 중에서, 간선의 가중치 합이 최소인 Spanning Tree를 말함

### 3] 최소 신장 트리 알고리즘
- 그래프에서 최소 신장 트리를 찾을 수 있는 알고리즘이 존재함
- 대표적인 최소 신장 트리 알고리즘
    - Kruskal's Algorithm (크루스칼 알고리즘)
    - Prim's Algorithm (프림 알고리즘)
    
### 4] 크루스칼 알고리즘 (Kruskal's Algorithm)
1. 모든 정점을 독립적인 집합으로 만든다.
2. 모든 간선을 비용을 기준으로 정렬, 비용이 작은 간선부터 양 끝의 두 정점을 비교한다.
    - 해당 연결됨에 따라서 그 결과로 사이클이 발생한다면, 해당 간선은 탈락하게 만든다.
3 . 두 정점의 최상위 정점을 확인하고 서로 다를경우 두 정점을 연결한다
    - 최소신장트리는 사이클이 없으므로 사이클이 생기지않도록 하는 것임.
    > 탐욕 알고리즘을 기초로 하고있다. 당장 눈 앞의 최소비용을 선택해서 결과적으로 최적의 솔루션을 찾는다.
   
### 5] Union-Find 알고리즘
- Disjoint Set을 표현할 때 사용하는 알고리즘으로 트리 구조를 활용하는 알고리즘
- 간단하게, 노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때(합칠 때) 사용한다.
- Disjoint Set이란
    - 서로 중복되지않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조
    - 공통 원소가 없는 (서로소) 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 자료구조를 의미한다.
    - Disjoint Set = 서로소 집합 자료 구조
  
#### 1] 초기화
- n개의 원소가 개별 집합으로 이뤄지도록 초기화
  <img src="https://www.fun-coding.org/00_Images/initial_findunion.png" width=400>
#### 2] Union
- 두 개별 집합을 하나의 집합으로 합침, 두 트리를 하나의 트리로 만듬
<img src="https://www.fun-coding.org/00_Images/union_findunion.png" width=600>
#### 3] Find
- 여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같으 그래프에 속하는지 판별하기 위해, 각 그룹의 최상단 원소(루트 노드)를 확인한다.
  <img src="https://www.fun-coding.org/00_Images/find_findunion.png" width=500>

### Union-Find 알고리즘의 고려할 점
- Union 순서에 따라서, 최악의 경우 링크드 리스트와 같은 형태가 될 수 있음.
- 이 때는 Find/Union 시 계산량이 O(N) 이 될 수 있으므로, 해당 문제를 해결하기 위해, union-by-rank, path compression 기법을 사용함

<img src="https://www.fun-coding.org/00_Images/worst_findunion.png" width=200>

### union-by-rank 기법
- 각 트리에 대해 높이(rank)를 기억해 두고,
- Union시 두 트리의 높이(rank)가 다르면, 높이가 작은 트리를 높이가 큰 트리에 붙임 (즉, 높이가 큰 트리의 루트 노드가 합친 집합의 루트 노드가 되게 함)
  <img src="https://www.fun-coding.org/00_Images/unionbyrank_findunion.png" width=700>

- 높이가 h - 1 인 두 개의 트리를 합칠 때는 한 쪽의 트리 높이를 1 증가시켜주고, 다른 쪽의 트리를 해당 트리에 붙여줌
  <img src="https://www.fun-coding.org/00_Images/unionbyranksame_findunion.png" width=700>

- 초기화시, 모든 원소는 높이(rank) 가 0 인 개별 집합인 상태에서, 하나씩 원소를 합칠 때, union-by-rank 기법을 사용한다면,
    - 높이가 h 인 트리가 만들어지려면, 높이가 h - 1 인 두 개의 트리가 합쳐져야 함
    - 높이가 h - 1 인 트리를 만들기 위해 최소 n개의 원소가 필요하다면, 높이가 h 인 트리가 만들어지기 위해서는 최소 2n개의 원소가 필요함
    - 따라서 union-by-rank 기법을 사용하면, union/find 연산의 시간복잡도는 O(N) 이 아닌, $ O(log{N}) $ 로 낮출 수 있음

### path compression
- Find를 실행한 노드에서 거쳐간 노드를 루트에 다이렉트로 연결하는 기법
- Find를 실행한 노드는 이후부터는 루트 노드를 한번에 알 수 있음

<center><img src="https://www.fun-coding.org/00_Images/pathcompression_findunion.png" width=400></center>

- union-by-rank 와 path compression 기법 사용시 시간 복잡도는 다음 계산식을 만족함이 증명되었음
    - $ O(M log^*{N}) $
    - $ log^*{N} $ 은 다음 값을 가짐이 증명되었음
        - N이 $ 2^{65536} $ 값을 가지더라도, $ log^*{N} $ 의 값이 5의 값을 가지므로, 거의 O(1), 즉 상수값에 가깝다고 볼 수 있음

<div style="text-align:left">
<table>
  <tr>
    <th style="text-align:center">N</th>
    <th style="text-align:center">$ log^*{N} $</th>
  </tr>
  <tr>
    <td style="text-align:left">1</td>
    <td style="text-align:left">0</td>
  </tr>
  <tr>
    <td style="text-align:left">2</td>
    <td style="text-align:left">1</td>
  </tr>
  <tr>
    <td style="text-align:left">4</td>
    <td style="text-align:left">2</td>
  </tr>
  <tr>
    <td style="text-align:left">16</td>
    <td style="text-align:left">3</td>
  </tr>
  <tr>
    <td style="text-align:left">65536</td>
    <td style="text-align:left">4</td>
  </tr>
  <tr>
    <td style="text-align:left">$ 2^{65536} $</td>
    <td style="text-align:left">5</td>
  </tr>
</table>
</div>

### 6] 시간 복잡도
- 크루스컬 알고리즘의 시간 복잡도는 O(E log E)
    - 다음 단계에서 2번, 간선을 비용 기준으로 정렬하는 시간에 좌우됨 (즉 간선을 비용 기준으로 정렬하는 시간이 가장 큼)
    1. 모든 정점을 독립적인 집합으로 만든다.
    2. 모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교한다.
        - 퀵소트를 사용한다면 시간 복잡도는 O(n log n) 이며, 간선이 n 이므로 O(E log E)
    3. 두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결한다. (최소 신장 트리는 사이클이 없으므로, 사이클이 생기지 않도록 하는 것임)
        - union-by-rank 와 path compression 기법 사용시 시간 복잡도가 결국 상수값에 가까움, O(1)

<img src="https://www.fun-coding.org/00_Images/kruscal_time.png">

### 7] Prim's Algorithm(프림 알고리즘)
- 최소신장 알고리즘
- 시장 정점을 선택한 후, 정점에 인접한 간선 중 최소간선으로 연결된 정적에서 다시 최소간선으로 정점을 선택하는 방식.

#### 크루스칼과 프림의 공통점과 차이점
- 공통점 : 둘다 탐욕 알고리즘. 당장 눈 앞의 최소비용을 선택해서 결과적으로 최적의 솔루션을 찾는다.
- 차이점 :
    - 크루스칼은 가장 작은 가중치의 간선부터 정렬하고 난 후 점에서 점으로 이동하면서 구함.
    - 프림은 특정 점에서 시작, 해당 점에서 가장 작은 가중치의 간선을 선택, 다시 선택 선택.. 반복
    
### 8] 프림알고리즘 이해하기
1. 임의의 정점을 선택, '연결된 노드 집합'에 삽입
2. 선택된 정점에 연결 된 간선들을 간선 리스트에 삽입
3. 간선 리스트에서 최소 가중치를 가지는 간선부터 추출해서,
    - 해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 이미 들어있다면 사이클을 막기위해 스킵
    - 들어있지 않다면 해당 간선을 선택하고 최소신장트리에 삽입
    
4. 추출한 간선은 간선 리스트에서 제거
5. 간선 리스트에서 더이상의 간선이 없을떄까지 반복
<img src="https://www.fun-coding.org/00_Images/prim_java_1.jpg" width=800>
<img src="https://www.fun-coding.org/00_Images/prim_java_2.jpg" width=800>
<img src="https://www.fun-coding.org/00_Images/prim_java_3.jpg" width=800>

### 프림 알고리즘 코드 (프로젝트: CH30_PRIM_BASIC)
0. 모든 간선 정보를 저장 (**adjacentEdges**)
1. 임의의 정점을 선택, '연결된 노드 집합(**connectedNodes**)'에 삽입
2. 선택된 정점에 연결된 간선들을 간선 리스트(**candidateEdgeList**)에 삽입
3. 간선 리스트(**candidateEdgeList**)에서 최소 가중치를 가지는 간선부터 추출해서,
    - 해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 이미 들어 있다면, 스킵함(cycle 발생을 막기 위함)
    - 해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 들어 있지 않으면, 해당 간선을 선택하고, 해당 간선 정보를 '최소 신장 트리(**mst**)'에 삽입
        - 해당 간선에 연결된 인접 정점의 간선들 중, '연결된 노드 집합(**connectedNodes**)' 에 없는 노드와 연결된 간선들만 간선 리스트(**candidateEdgeList**) 에 삽입
            - '연결된 노드 집합(**connectedNodes**)' 에 있는 노드와 연결된 간선들을 간선 리스트에 삽입해도, 해당 간선은 스킵될 것이기 때문임
            - 어차피 스킵될 간선을 간선 리스트(**candidateEdgeList**)에 넣지 않으므로 해서, 간선 리스트(**candidateEdgeList**)에서 최소 가중치를 가지는 간선부터 추출하기 위한 자료구조 유지를 위한 effort를 줄일 수 있음 (예, 최소힙 구조 사용)


4. 선택된 간선은 간선 리스트에서 제거
5. 간선 리스트에 더 이상의 간선이 없을 때까지 3-4번을 반복
   
