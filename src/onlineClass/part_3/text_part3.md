# 한번에 끝내는 코딩 테스트 369

1. [**MJ's Jupyter notebook**](http://localhost:8888/tree/Jupyter/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_%EC%9E%90%EB%A3%8C_20210426)
    - Jupyter notebook 실행 후 해당 주소로 접근하기

## 3-1. 코딩테스트 연습
#### 난이도
1. 문법을 알고있다.
2. 알고리즘과 자료구조를 이해하고 있다.
3. 정확한 선택을 통해 문제를 풀 수 있다.
4. 코테에서 정답률 10퍼센트 되는 문제
5. 코테 수준의 지식만 사용하지만, 풀이를 떠올리기 쉽지않고 구현 난이도도 상당한 문제

#### 카카오 블라인드 테스트
- 문자열 관련 문제가 항상 나옴
- 백트래킹을 통한 완전 탐색을 중요시 한다.
- 지원자 수준의 상한선을 다른 기업들보다 훨씬 높은 곳까지 파악하려고 한다.
- 그럼에도 불구하고 학부 수준의 자료구조, 알고리즘 지식을 벗어나는 경우는 없게 내려고 노력한다

#### 최신 코딩 테스트 분석
- 필수 테크닉
   - 정렬
   - 문자열 처리
   - Dinamic Programing(DP)
   - Dikstra
   - 너비 우선 탐색(BFS) & 깊이 우선 탐색 (DFS)
   - 완전탐색
   - 이분탐색
   
- 높은 난이도로 나오는 알고리즘
   - 배열에서의 DP
   - Tree에서의 DP
   - 투 포인터
   - 위상 정렬
   
- 자료 구조
   - HashMap
   - Deque (queue)
   - Stack
   - Priority Queue
   - Dynamic Array
   
#### 코딩 테스트를 위한 좋은 습관
- 좋은 습관
   - 문제를 올바른 순서로 이해한다.
      1. 읽기
         - 시간, 메모리 제한
         - 문제 전체를 꼼꼼히 읽기.
      2. 이해하기
         - 제공되는 정보(변수) 정리
         - 예제 데이터에 대해 이해
      3. 파악하기
         - 가능한 최대, 최소 정답에 맞는 데이터를 직접 생성
         - 키워드가 되는 단어들을 체크한다.
   - 시간과 공간 복잡도를 계산한다
     - 시간을 아끼기 위해서 : "짤 가치가 있는가?"
      - BFS & DFS (w/인접리스트)
         - 시간복잡도 : O(V+E)
         - 공간복잡도 : O(V+E)
      - Dijkstra
         - 시간복잡도 : O(E log E) or O(E log V)
         - 공간복잡도 : O(V+E)
      - Quick Sort
         - 시간복잡도 : 최선[O(N log n)], 최악[O(N^2)]
         - 공간복잡도 : O(V)
      - Binary Search
         - 시간복잡도 : O(N log N)
         - 공간복잡도 : O(N)
      
   - 코드를 효율적으로 함수화 해서 구현한다.
      - 코드가 길어지면 길어질수록 실수 할 구간이 많아진다.
      - 반복 코드는 최대한 줄이게 하자.
   
   - 코딩 테스트에서 부분 점수를 챙긴다.
      - 코딩 테스트는 점수싸움.