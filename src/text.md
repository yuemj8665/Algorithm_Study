# 한번에 끝내는 코딩 테스트 369

1. [**MJ's Jupyter notebook**](http://localhost:8888/tree/Jupyter/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_%EC%9E%90%EB%A3%8C_20210426)
    - Jupyter notebook 실행 후 해당 주소로 접근하기

## 1. 배열
### 배열이란?
- 같은 종류의 데이터를 효율적으로 관리하기 위해 사용
- 같은 종류의 데이터를 순차적으로 저장
- 장점:
    - 빠른 접근 가능
        - 첫 데이터의 위치에서 상대적인 위치로 데이터 접근(인덱스 번호로 접근)
- 단점:
    - 데이터 추가/삭제의 어려움
        - 미리 최대 길이를 지정해야 함
    
#### 참고: List 와 ArrayList
- 다음과 같이 List 와 ArrayList 선언의 차이점
```java
List<Integer> list1 = new ArrayList<Integer>();
ArrayList<Integer> list1 = new ArrayList<Integer>();
```

- List 는 인터페이스이고, ArrayList 는 클래스임
    - 클래스는 크게 일반 클래스와 클래스 내에 '추상 메서드' 가 하나 이상 있거나, abstract 로 정의된 추상 클래스로 나뉨
    - 인터페이스는 모든 메서드가 추상 메서드인 경우를 의미하며, 인터페이스를 상속받는 클래스는 인터페이스에서 정의된 추상 메서드를 모두 구현해야 함 (**따라서 다양한 클래스를 상속받는 특정 인터페이스는 결국 동일한 메서드를 제공함**)
    - ArrayList 가 아니라, List 로 선언된 변수는 다음과 같이 필요에 따라 다른 리스트 클래스를 쓸 수 있는 **구현상의 유연성** 을 제공함
      ```java
         List<Integer> list1 = new ArrayList<Integer>();
         list1 = new LinkedList<Integer>();
      ```
    - 다만, 본 자료구조/알고리즘에서는 굳이 동일 변수에 다양한 리스트 클래스를 쓸 필요는 없으므로, 최대한 동일한 클래스로 선언하기로 함
      ```java
         ArrayList<Integer> list1 = new ArrayList<Integer>();
      ``` 
    - 이외에  JDK 1.7 이상부터는 인스턴스 생성 시 타입을 추정할 수 있는 경우에는 타입을 생략할 수 있으므로, 다음과 같이 작성 가능하지만, 가능한 JAVA 버전 제한하지 않기 위해, 본 강의에서는 아래 보다는, 가능한 위의 코드처럼 타입을 생략하지 않기로 함
      ```java
         ArrayList<Integer> list1 = new ArrayList<>();
      ``` 

#### 참고: Primitive 자료형과 Wrapper 클래스
- JAVA 에서는 int 와 Integer 같이, Primitive 자료형과 Wrapper 클래스가 있음
- 본 강의 내에서는 Integer 와 같은 Wrapper 클래스가 다음과 같은 이유로, 사용되며, 가급적 복잡도를 낮추기 위해, Primitive 와 마구 혼용하기 보다는 주로 Wrapper 클래스를 사용하기로 함 (필요 시에만 Primitive 자료형을 사용하기로 함)
    - null 을 용이하게 처리할 수 있고,
    - ArrayList 등 객체만을 핸들링 하는 기능을 사용하기 위해
    
## 2. 큐(queue)
### 1] 큐(queue) 란?
- 줄을 세우는 행위
- 가장 먼저 넣은 데이터를 가장 먼저 꺼낸다.
- 현실세계의 줄서기와 유사함
- FIFO(First In, First Out), LILO(Last In, Last Out)
- 스택(stack)과 반대되는 개념이다.  
  <img src="https://www.fun-coding.org/00_Images/queue.png" />
* 출처: http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/

### 2] 알아둘 용어
- Enqueue: 큐에 데이터를 넣는 기능
- Dequeue: 큐에서 데이터를 꺼내는 기능 
- Visualgo 사이트에서 시연해보며 이해하기 (enqueue/dequeue 만 클릭해보며): https://visualgo.net/en/list

### 3] JAVA 에서의 큐 자료 구조 사용하기
* JAVA 에서는 기본적으로 java.util 패키지에 Queue 클래스를 제공하고 있음
    - Enqueue 에 해당하는 기능으로 Queue 클래스에서는 add(value) 또는 offer(value) 메서드를 제공함
    - Dequeue 에 해당하는 기능으로 Queue 클래스에서는 poll() 또는 remove() 메서드를 제공함
    - 아쉽게도, Queue 클래스에 데이터 생성을 위해서는 java.util 패키지에 있는 LinkedList 클래스를 사용해야 함
        - LinkedList 클래스는 자료구조의 링크드리스트 와 연관이 있으며, 관련 내용은 큐보다 복잡하므로 이후 챕터에서 상세히 익히도록 함

### 참고: 어디에 큐가 많이 쓰일까?
- 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨 (운영체제 참조)

> 큐의 경우에는 장단점 보다는 (특별히 언급되는 장단점이 없음), 큐의 활용 예로 프로세스 스케쥴링 방식을 함께 이해해두는 것이 좋음

## 3. 스택(Stack)
### 1] 스택(Stack) 이란?
- 책을 쌓는 행위
- 가장 먼저 넣은 데이터를 가장 나중에 꺼낸다.
- LIFO(Last In First Out), FILO(First In Last Out)
- 큐(Queue)와는 반대되는 개념이다.
* 데이터를 제한적으로 접근할 수 있는 구조
    - 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조
* 가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조
    - 큐: FIFO 정책
    - 스택: LIFO 정책
    
### 2] 알아둘 용어
- push() : 데이터를 스택에 넣기
- pop() : 데이터를 스택에서 빼기
  <img src="http://www.fun-coding.org/00_Images/stack.png" />
  
### 3] 장단점
* 장점
    - 구조가 단순해서 구현이 쉽다.
    - 데이터의 저장/읽기 속도가 빠르다.
    
* 단점
    - 일반적인 스택 구현시 데이터의 최대갯수를 정해놔야 한다(배열의 크기)
    - 저장공간의 낭비가 있을 수 있다.(미리 최대갯수의 저장 공간을 확보해놓아야 한다.)
    
### 3] Java에서 스택 자료구조 사용해보기
##### JAVA Stack 클래스
- java.util 패키지에서 Stack 클래스 제공
    - push(아이템) 메서드 : 아이템을 Stack 에 추가
    - pop() 메서드 : Stack 에서 마지막에 넣은 아이템을 리턴하고, 해당 아이템은 Stack 에서 삭제된다. 
    
## 4. 링크드리스트
### 1] SingleLinkedList 란?
- 연결리스트 라고도 한다.
- 한칸은 **노드**라고 하며, 노드안에서 다음 노드의 데이터를 가지고있는 부분을 **포인터**라 한다.
- 포인터가 가지고있는 데이터와 다음 노드는 주소값이 같더라?

### 2] 장단점
* 장점
    - 저장공간 낭비가 없다.
        - 배열은 미리 공간을 만들어놔야 하지만, Linkedlist는 굳이 그러지않아도 된다.
    
* 단점
    - 연결을 위해 별도 데이터 공간이 필요하므로(포인터) 저장 공간 효율이 안좋다.
    - 포인터를 통해 검색하기 때문에 검색 속도가 느리다.
    - 데이터의 변경(삽입,삭제 등)이 이루어지면 데이터의 앞뒤에 가공이 필요하다
        - 0-1-2 순의 데이터를 기준으로
            - 1 앞에 새로운 데이터 3을 삽입한다고하면 0-3을 연결, 3-1을 연결하는것이 삽입이다.
            - 데이터 1을 삭제한다고 하면 0-2를 이어주면 1의 데이터는 자연스레 링크된것이 없어 사라지게된다.
    - 유지 관리에 부가적인 구현이 필요하다.
      <img src="https://www.fun-coding.org/00_Images/linkedlistadd.png" />
      
### 2] Double Linked List
- 이중연결 리스트라고 한다.
- 양방향으로 연결되어있어 노드 탐색이 양쪽으로 가능하다.
- 공부할떄에는 디버깅을 적극 이용하자. 이해에 도움이 된다.
      <img src="https://www.fun-coding.org/00_Images/doublelinkedlist.png" />
  
## 5. 알고리즘 복잡도
### 1] 알고리즘 복잡도 계산이 필요한 이유
- 어느 알고리즘이 더 좋은지 분석하기 위해 복잡도를 정의하고 계산한다.
### 2] 알고리즘 복잡도 계산항목
- 시간 복잡도 : 알고리즘 실행 속도
- 공간 복자도 : 알고리즘이 사용하는 메모리 사이즈
    - 중요도 : 시간 복잡도 > 공간 복잡도
    - 가장 중요한 시간 복잡도를 이해하고 계산할 줄 알아야한다.
    
1. 시간 복잡도의 주요 요소
    - **반복문**이 지배한다.
    
2. 프로그래밍에서 시간 복잡도에 가장 영향을 많이 미치는 요소는 **반복문**
    - 입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행시간을 지배한다.
    
3. 알고리즘 성능 표기법
    - Big O (빅-오) 표기법: O(N)
        - 알고리즘 최악의 실행 시간을 표기
        - **가장 많이/일반적으로 사용함**
        - **아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문**
            * 빅 오 표기법, Big-O 표기법 이라고도 부름
                * O(입력)
                - 입력 n 에 따라 결정되는 시간 복잡도 함수
                - O(1), O( 𝑙𝑜𝑔𝑛 ), O(n), O(n 𝑙𝑜𝑔𝑛 ), O( 𝑛2 ), O( 2𝑛 ), O(n!)등으로 표기함
                - 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
                - O(1) < O( 𝑙𝑜𝑔𝑛 ) < O(n) < O(n 𝑙𝑜𝑔𝑛 ) < O( 𝑛2 ) < O( 2𝑛 ) < O(n!)
                - 참고: log n 의 베이스는 2 -  𝑙𝑜𝑔2𝑛
                  <img src="https://cdn.discordapp.com/attachments/663061737276309513/859411427604824085/b5dabc58bf160e7a.png"/>
     - Ω (오메가) 표기법:  Ω(N)
        - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기

    - Θ (세타) 표기법: Θ(N)
        - 오메가 표기법은 알고리즘 평균 실행 시간을 표기

    > 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중, 최악의 시간인 Big-O 표기법을 중심으로 익히면 됨 
  
## 6. 해쉬 테이블 (HashTable)
### 1] 해쉬 테이블
- key와 value를 이용하여 매핑하는 자료구조
- java의 Map과 비슷한것 같다.
- 주소를 저장하여 key에 해당하는 데이터를 빠르게 찾을 수 있다.

### 2] 알아 둘 용어
- 해쉬 함수 : 임의의 데이터를 고정된 길이의 값으로 리턴해주는 함수 (key)
    - 해쉬, 해쉬 값, 또는 하쉬 주소 : 해싱 함수를 통해 리턴된 고정된 길이의 값
    
- 해쉬 테이블 : 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조 (value)
    - 슬롯 : 해쉬 테이블에서 한개의 데이터를 저장 할 수 있는 공간

### 3] 장단점
- 장점
    - 데이터 저장/읽기 속도가 빠름(검색 속도가 빠름)
    - 해쉬는 키에 대한 데이터가 있는지(중복체크) 확인이 쉬움
    
- 단점
    - 일반적으로 저장 공간이 좀 더 많이 필요하다
    - **여러 키에 해당하는 주소가 동일 할 경우 충돌을 회피하기 위한 별도 자료구조가 필요하다**
    
- 주요 용도
    - 검색이 많이 필요한 경우
    - 저장,삭제,읽기가 빈번한 경우
    - 캐쉬 구현시 (중복 확인이 쉽기 때문이다.)
    - 굉장히 빠른 속도!
    
### 4] 충돌(Collision) 해결 알고리즘 (좋은 해쉬 함수 사용하기)
    해쉬 테이블의 가장 큰 문제는 충돌의 경우.
    이 문제를 충돌, 또는 해쉬 충돌이라고 부른다.

### 5-1] Chaining 기법
- 개방해슁, 또는 Open Hashing 기법 중 하나 : 해쉬 테이블 저장 공간 외에 공간을 활요하는 방법
- 충돌이 일어나면 링크드 리스트 자료구조를 이용하여 링크드 리스트 데이터를 추가로 뒤에 연결시켜서 저장한다.


### 5-2] Linear Probing 기법
- 폐쇄해슁, 또는 Close Hashing기법 중 하나 : 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법
- 충돌이 일어나면 해당 hash address의 다음 address부터 맨 처음 나오는 빈 공간에 저장하는 기법
    - 저장 공간 활용도를 높이기 위한 기법
    
### 6] 시간 복잡도
- 일반적인 경우(충돌이 없는 경우) O(1)
- 최악의 경우(충돌이 모두 발생하는 경우) O(n)
- Linear Probing, Chaining 기법 둘다 동일하다
    해쉬 테이블의 경우는 일반적인 경우를 기대하고 작성한다
  
### 7] 검색에서 해쉬 테이블의 사용 예
- 배열에 데이터를 저장하고 검색할 때 O(n) -> 2번이상 사이클을 돌기 때문
- 이상적인 해쉬 테이블 케이스에서 데이터를 검색 할 떄 O(1)

## 7. 트리
- 트리 자료구조는 굉장히 유용한 자료구조, 꼭 알아두어야 함
- 트리라는 자료구조를 유지하기 위해서 작성해야하는 난이도는 가장 높다. 자료구조상에서 끝판왕.
- Node와 Branch를 이용해서 **사이클을 이루지 않도록** 구성한 데이터 구조.
- 어디에서 많이 사용되는지?
    - 트리 중 이진 트리 형태의 구조로 탐색 알고리즘 구현을 위해 많이 사용 됨.

### 1. 알아둘 용어
- Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
- Root Node: 트리 맨 위에 있는 노드
- Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄
- Parent Node: 어떤 노드의 다음 레벨에 연결된 노드
- Child Node: 어떤 노드의 상위 레벨에 연결된 노드
- Leaf Node (Terminal Node): Child Node가 하나도 없는 노드
- Sibling (Brother Node): 동일한 Parent Node를 가진 노드
- Depth: 트리에서 Node가 가질 수 있는 최대 Level
  <img src="http://www.fun-coding.org/00_Images/tree.png" width="600" />

### 2. 이진 트리와 이진 탐색 트리 (Binary Search Tree)
- 이진 트리: 노드의 최대 Branch가 2인 트리
- 이진 탐색 트리 (Binary Search Tree, BST): 이진 트리에 다음과 같은 추가적인 조건이 있는 트리
    - 왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지고 있음!

<img src="https://www.mathwarehouse.com/programming/images/binary-search-tree/binary-search-tree-insertion-animation.gif" />

(출처: https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node)

### 3. 자료 구조 이진 탐색 트리의 장점과 주요 용도
- 주요 용도: 데이터 검색(탐색)
- 장점: 탐색 속도를 개선할 수 있음

> 단점은 이진 탐색 트리 알고리즘 이해 후에 살펴보기로 함

### 이진트리와 정렬된 배열간의 탐색 비교
<img src="https://www.mathwarehouse.com/programming/images/binary-search-tree/binary-search-tree-sorted-array-animation.gif" />

(출처: https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node)

### 4. 시간 복잡도 (탐색 시)
- depth(트리의 높이)를 h로 표기한다면 O(h)
- n개의 노드를 가진다면, h - log2n에 가까우므로, 시간 복잡도는 O(log n)
    - 참고 : 빅오 표기법에서 log n 에서의 log의 밑은 10이 아니라 2입니다.
        - 한번 실행 시 마다, 50%의 실행할수도 있는 명령을 제거한다는 의미.
        - 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미함.
    
### 5. 단점
- 평균 시간 복잡도는 O(logn)이지만, 이는 트리가 균형잡혀있을때의 평군 시간복잡도이며,
- 다음 예와 같이 구성되어있을 경우 최악의 경우에는 LinkedList 등과 동일한 성능을 보여준다(O(n))
  <img src="http://www.fun-coding.org/00_Images/worstcase_bst.png" width="300" />
  
## 8. 힙
- 힙이란 데이터에서 최대값과 최소값을 빠르게 찾기 위한 **완전이진트리**
    - 완전 : 노드를 삽입할때 최하단 왼쪽 노드부터 차례대로 삽입한다.
      <img src="https://www.fun-coding.org/00_Images/heap_ordinary.png">
- 배열이라면 모든 데이터를 한번씩 다 순회 후에 해야 하지만 (O(n))
- 이에 반해 힙에 데이터를 넣고 최대값과 최소값을 찾으면 O(logn)이 걸림
- 우선순위 큐와 같이 최대값, 최소값을 빠르게 찾아야하는 자료구조 및 알고리즘 구현에 활용된다.
    - 우선순위 큐 : 각각의 데이터를 넣을 때 우선순위를 같이 기재해서 넣고, 빼낼때에는 우선순위가 가장 높은 데이터를 먼저뽑는다.
    - 우선순위 큐는 내부적으로 힙을 사용하여 구현한다.
    
### 1. 힙과 이진탐색트리의 공통점과 차이점
- 공통점 : 힙과 이진탐색트리는 모두 이진트리
- 차이점 :
    - 힙은 각 노드의 값이 자식노드보다 크거나 같음(Max heap의 경우)
    - 이진 탐색트리는 왼쪽 자식의 노드값이 더 작고 그 다음 부모노드, 그 다음 오른쪽 자식 노드값이 가장 크다.
    - 힙은 이진 탐색트리의 조건인 "자식노드에서 작은 값은 왼쪽, 큰 값은 오른쪽"으로 같은 조건은 없다.
        - 힙의 왼쪽 노드, 오른쪽 노드의 값의 비교는 어느쪽이 더 클지 모름
    - 이진 탐색 트리는 탐색을 위한 구조, 힙은 최대값, 최소값을 구하기 위한 구조로 이해하면 됨.
    
### 2. 힙의 구조
- 힙은 최대값을 구하기 위한 최대 힙(Max Heap), 최소값을 위한 최소 힙(Min Heap)으로 구분한다.
- 힙은 다음과 같이 두 가지 조건을 가지고있는 자료구조이다.
    1. 각 노드의 값은 해당 노드의 자식노드가 가진 값보다 크거나 같다(최대 힙의 경우)
        - 최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 크거나 작다.
    2. 완전 이진트리이 형태를 가진다.
    
### 3. 힙 동작
- 데이터를 힙 구조에 삽입하는 과정을 그림을 통해 선명하게 이해하기

### 힙에 데이터 삽입하기 - 삽입할 데이터가 힙의 데이터보다 클 경우 (Max Heap 의 예)
- 먼저 삽입된 데이터는 완전 이진 트리 구조에 맞추어, 최하단부 왼쪽 노드부터 채워짐
- 채워진 노드 위치에서, 부모 노드보다 값이 클 경우, 부모 노드와 위치를 바꿔주는 작업을 반복함 (swap)
  <img src="https://www.fun-coding.org/00_Images/heap_insert.png">

### 힙의 데이터 삭제하기 (Max Heap 의 예)
- 보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적임(큐 처럼 가져가면 삭제된다.)
    - 힙의 용도는 최대값 또는 최소값을 root 노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는 것임
- 상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드 (일반적으로 가장 마지막에 추가한 노드) 를 root 노드로 이동
- root 노드의 값이 child node 보다 작을 경우, root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복함 (swap)

<img src="https://www.fun-coding.org/00_Images/heap_remove.png">

### 4. 힙 구현하기
- 일반적으로 인덱스 0번부터 시작. 힙 구현의 편의를 위해서 root 노드의 인덱스 값을 1로 시작하면 구현이 더 수월하다. (0번 인덱스는 null을 배치하여 시작)
    - 부모노드 인덱스번호 = 자식 노드 인덱스 번호 / 2
    - JAVA는 연산자로 몫을 구할 수 있다.
    - 왼쪽 자식 노드 인덱스번호 = 부모노드 인덱스번호 * 2
    - 오른쪽 자식 노드 인덱스 번호 = 부모노드 인덱스번호 * 2 + 1
      
- 힙 구현에 사용된 Collectio.swap()메서드 사용법 이해하기
    - swap이란 두 데이터의 위치를 맞바꾸는것을 의미한다.
    - swap 함수를 별도로 구현할 수도 있지만 java에서는 Collection 패키지에서 swap()메서드를 제공해주고 있다.
        - 하나의 배열 안에있는 두 데이터의 위치를 서로 바꾸고싶을때 가능

### 5. 힙의 시간 복잡도
- depth(트리의 높이)를 h라고 표기한다면
- n개의 노드를 가지는 heap에 데이터삽입 또는 삭제 시 최악의 경우 root노드에서 leaf노드까지 비교해야 하므로, h=log2n에 가까우므로 시간복잡도는 O(logn)
    - 참고 : 빅오 표기법에서 logn에서의 log의 밑은 10이 아니라 2이다.
    - 한번 실행시마다 50%의 실행할수도있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미함
    
## 9. 공간 복잡도
### 1] 알고리즘 계산 복잡도는 두가지를 계산한다
- 시간 복잡도 : 얼마나 빠르게 실행 되는가
- 공간 복잡도 : 얼마나 많은 저장 공간이 필요한가
    > 좋은 알고리즘은 실행 시간도 짧고 저장 공간도 적게써야함
  > 
- 근데 보통은 둘다 만족하기는 어렵다.
    - 시간과 공간은 반비례적인 관계이다
    - 최근 대용량 시스템이 보편화 되면서 공간 복잡도 보다는 시간복잡도가 우선이다.
    > 결론은 시간 복잡도를 기준으로 하자.
  > 
- 그래도 공간복잡도 대략적인 계산은 필요하다.
    - 기존 알고리즘 문제는 예전의 공간복잡도도 고려해야할 때 만들어진 경우가 많다.
    - 그래서 기존 알고리즘 문제에 시간 복잡도 뿐만 아니라 공간 복잡도 제약사항을 거는 경우가 있다.
    - 면접시에 공간 복잡도를 묻는 경우도 있다.
        - 최근 현업에서 빅데이터를 다룰때에는 저장공간을 고려해서 구현하는 경우도있다.
    

### 2] 공간 복잡도
- 프로그램을 실행 및 완료하는데 필요한 저장공간의 양을 뜻한다.
- 총 필요 저장 공간
    - 고정 공간(알고리즘과 무관한 공간) : 코드 저장 공간, 단순 변수 및 상수
    - 가변 공간(알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간
        - S(P) = c + Sp(n)
        - c: 고정공간
        - So(n) : 가변공간
    > 빅오 표기법을 생각해볼떄 고정 공간은 상수이므로 공간 복잡도는 가변공간에 좌우된다.
  > 입력 갯수에 따라서 고정 공간이 한계적으로 얼마나 늘어나느냐 기반으로 계산을 한다.
  > 
## 10. 버블정렬
### 0. 알고리즘 연습방법
- 알고리즘을 잘 작성하기 위해서는 잘 작성된 알고리즘을 이해하고 스스로 만들어봐야 한다.
    - 모사!  그림을 잘 그리기 위해서는 잘 그린 그림을 모방하는 것 부터 시작하는게 좋다.
    > 이번 챕터부터 알고리즘의 시작
  
- 알고리즘 연습 방법
1. 연습장과 펜을 준비
2. 알고리즘 문제를 읽고 분석 한 뒤
3. 간단하게 테스트용으로 매우 간단한 경우부터 복잡한 경우를 순서대로 생각해보면서 연습장과 펜을 이용하여 알고리즘을 분석한다.
4. 가능한 알고리즘이 보인다면, 구현할 알고리즘을 세부 항목(Case)으로 나누고, 문장으로 세부항목을 나누어서 적는다.
5. 코드화 하기 위해, 데이터 구조 또는 사용 할 변수를 정리
6. 각 문자을 코드 레벨로 적는다
7. 변수가 코드에 따라 어떻게 변하는지 손으로 적으면서 임의 데이터로 코드가 정상 동작하는지를 연습장과 펜으로 검증한다.
> 분석을 잘 한다면 손코딩에서도 굉장히 유용하다.
> 
> 코딩 테스트는 오랜 고민 끝에 소스를 입력해야한다. 

### 1. 정렬(Sorting) 이란?
- 정렬(sorting) : 어떤 데이터들이 이를 정해진 순서대로 나열하는 것
- 정렬은 프로그램 작성 시 빈번하게 필요로 한다.
- 다양한 알고리즘이 고안되어있으며, 알고리즘 학습의 필수이다.

###2. 버블 정렬이란?
- 두 인접한 데이터를 비교해서 앞에 있는 데이터가 뒤에있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘.

###3. 어떻게 코드로 짜는가?
> 알고리즘 연습 방법에 기반해서 단계별로 생각하기
```java
public static class BubbleSort{
        /**
         * 데이터가 4개 이상일때 버블정렬하기
         * 특이점 :
         * n개의 리스트가 있는 경우 최대 n-1번의 로직을 적용한다.
         * 로직을 1번 적용할 때마다 가장 큰 숫자가 뒤에서부터 1개씩 결정된다.
         * 로직이 경우에따라 일찍 끝날 수도있다.
         * 따라서 로직을 적용할때 한번도 데이터가 교환된 적이 없다면 이미 정렬된 상태이므로 더이상 로직을 반복 적용할 필요가 없다.
         *
         * @param dataList
         * @return
         */
        public ArrayList<Integer> sort(ArrayList<Integer> dataList) {
            for (int i = 0; i < dataList.size() - 1; i++) {
                boolean swap = false;
                for (int index = 0; index < dataList.size() - 1 - i; index++) {
                    if (dataList.get(index) > dataList.get(index + 1)) {
                        Collections.swap(dataList,index,index+1);
                        swap = true;
                    }
                }
                if (swap == false) {
                    break;
                }
            }
            return dataList;
        }
    }
```

###4. 복잡도 계산하기
- 반복문이 2개 O(n^2)
  <img src="https://blogfiles.pstatic.net/MjAyMTA3MThfMjgg/MDAxNjI2NjE0ODcxNDI1.afG-SHEu-V2kFmdAGFzrnn0C0HoEapUFo5cwiiOUEIQg.FaXeRkEUPN7krreva6I8gNJgtd9IpppJpxsWzmGDkOYg.PNG.yuemj/%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%B4_2%EA%B0%9C.png?type=w1" />
    - 최악의 경우 n(n-1)/2
- 완전정렬이 되어있는 경우 O(n)
> 버블 정렬을 알고리즘 연습 방법에 따라서 코드를 보지않고 연습하기.

## 11. 선택정렬
### 1] 선택정렬이란?
- 다음과 같은 순서를 반복하며 정렬하는 알고리즘
    - 주어진 데이터 중, 최소값을 찾는다
    - 해당 최소값을 데이터 맨 앞에 위치한 값과 교체한다
    - 맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복한다.

#### 직접 눈으로 보면 더 이해가 쉽다: https://visualgo.net/en/sorting

<img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" width=100>

### 2] 코드를 만드는 방법?
> 간단히 로직에 집중해서 각각의 데이터가 저장되어있는 배열이 있다고 가정하기

- 데이터가 두 개 일떄,
    - 예 : DataList[0]과 DataList[1]의 값을 교환한다.
    
- 데이터가 세 개 일때,
    - 예 : dataList = [9,1,7]
    - 1번 실행 : [1,9,7]
    - 2번 실행 : [1,7,9]
    
- 데이터가 네 개 일때,
    - 예 : dataList = [9,3,2,1]
    - 1번 실행 : [1,3,2,9]
    - 2번 실행 : [1,2,3,9]
    - 3번 실행 : 변화 없음으로 회전 끝
    
### 3] 알고리즘 분석
- 반복문이 2개 O(n^2)
    -실제로 상세하게 표현하자면 n(n-1)/2
- 버블정렬과 비슷하다.

## 11. 삽입정렬
### 0] 삽입정렬이란?
- 삽입 정렬은 두번째 인덱스부터 시작한다.
- 해당 인덱스 값(key값) 앞에 있는 데이터부터 비교해서 key값이 더 작으면 B값을 뒤 인덱스로 복사
- 이를 key값이 더 큰 데이터를 만날때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 key값을 이동.
  <img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" />


### 1] 어떻게 코드로 만들까?
> 알고리즘 연습 방법에 기반하여 단계별로 생각하기
- 데이터가 두 개일 때 삽입정렬
  - 데이터 예시 list = [5,3]
  - 3이 보다 작음으로 교환, 결과적으로 [3,5]가 됨
- 데이터가 세 개일 때 삽입정렬
  - 데이터 예시 list = [5,3,2]
  - 두 번째 인덱스부터 시작, 3이 더 작음으로 3이 앞으로 가게됨 [3,5,2]
  - 세 번쨰 인덱스 시작, 2는 5보다 작고, 3보다도 작음 [2,3,5]
  - think) 세 번쨰 인덱스 시작 시, 2와 5와 3을 비교할때에 앞자리와 비교하는 반복문을 사용하는 것 같다.
- 데이터가 네 개일 때 삽입정렬
    - 데이터 예시 list = [5,3,2,4]
    - 두 번째 인덱스부터 시작, 3이 더 작음으로 3이 앞으로 가게됨 [3,5,2,4]
    - 세 번쨰 인덱스 시작, 2는 5보다 작고, 3보다도 작음 [2,3,5,4]
    - 네 번쨰 인덱스 시작, 4는 5보다 작고 3보다 크므로 [2,3,4,5]
    - think) 네 번쨰 인덱스가 3과 비교할때에는 어차피 앞쪽 인덱스와 더이상 비교를 할 이유가 없으니 false를 반환해서 앞자리와 비교하는 반복문을 끝내면 좋을 것 같다.
 
   
- 반복해야 되는 것.
  - list의 한 사이클의 회전이 필요함(list.size()-1)
  - list안에서 본인의 인덱스 앞쪽 비교해야하는데, 이걸 계속 반복하다가 break를 걸어야한다.
    - 비교하다가 앞쪽과 비교해서 작으면 스왑해야한다. 크다면 break.
> 데이터가 반복문이 되는것을 생각 해 보자.
> 

### 2] 알고리즘 분석
- 반복문은 2개가 있다.
- 최악의 경우 모든 회전을 닿는다.
- 완전 정렬이 되어있다면 반복문은 단 한번만 돌게된다.
